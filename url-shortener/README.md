Assumptions:

- urls are randomly generated by the service
- If a GET request is made to the shortened URL then the user will be redirected to the the original URL
- The short urls will have a TTL
- Dealing with a maximum of a billion active urls at the same time
- A valid url is what Uri.uri can parse (same as java.net.URI)





Notes:

- TODOS
- might be needed if some links are accessed much more often than others, 
  use cache with expiry for most frequently accessed urls (LRU, Map + java.util.LinkedHashMap) 
- use java.net.URI instead of http4s' Uri to decrease coupling to the framework (using as it is in Scala, more convenient)
- the tests could do with some additional cleaning
- short url combinations, 36^10, collisions are unlikely
- use ELB to spread the load horizontally
- as an extreme, shard the db: hash based for instance (we have a set maximum of urls), another possibility is using a
  lookup table for the partitioned data, but then becomes a single point of failure 
- have janitor job to remove outdated items or use ttl directly like in redis
- if it were an expensive process to generate url (e.g. dns etc), or storing it, make asynchronous, request gets into queue, 
  then processed by other job, and the user gets optionally notified.
- Store page content too, separate repo and join data in the controller (perhaps can add summary to the object in memory). 




Run:

- sbt run
- curl -H "Content-Type: application/json" -d '{"url": "www.hello.com"}' http://localhost:8080/shorten_url
- curl -i localhost:8080/BdhHbLINOA


Use cases:

- Shortening a URL to a Short Url.
- Redirecting to the URL associated with a Short Url.

